<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-04T10:33:46+02:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Monad+</title><author><name>Arnau Abella</name></author><entry><title type="html">Small form factor PC</title><link href="http://localhost:4000/pc/2024/05/02/small-case-build/" rel="alternate" type="text/html" title="Small form factor PC" /><published>2024-05-02T00:00:00+02:00</published><updated>2024-05-02T00:00:00+02:00</updated><id>http://localhost:4000/pc/2024/05/02/small-case-build</id><content type="html" xml:base="http://localhost:4000/pc/2024/05/02/small-case-build/">&lt;p&gt;I had some spare components from previous builds at home and I was wondering what I could do with them.
At first, I thought about using the hardware on a new home server, but it was not a good fit for such use case due to the high power consumption parts.
Then I saw my fiancé playing a video game on her Mac Book Air on the sofa — I knew it was time to give her a proper gaming PC.&lt;/p&gt;

&lt;p&gt;Now, the question was: what type of case should I pick?
Over the years, I have swung from rgb-packed aesthetic-oriented cases to larger performance-oriented cases.
I don’t need my computer to look nice, I need my computer to run cool and quiet.
This is why I avoid small form factor (SFF) cases. 
Tiny cases make building the computer difficult, and running them cool and quiet is often challenging.
In this case, space was a deciding factor, so it had to be some kind of SFF case.&lt;/p&gt;

&lt;p&gt;After some research, I found out that SFF cases have improved a lot since the last time I built one (circa 2018).
In the end, I ended up buying the &lt;a href=&quot;https://www.coolermaster.com/catalog/max/mini-itx/nr200p-max/&quot;&gt;Cooler Master NR200P MAX&lt;/a&gt;.
I picked this one because it was advertised as easy to build, had really great value (350 € including the case, custom AIO 240mm and fans, and a SFF PSU 850W Gold), and had pretty good cooling performance.&lt;/p&gt;

&lt;h2 id=&quot;hardware&quot;&gt;Hardware&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;CPU: &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/sku/134595/intel-core-i712700kf-processor-25m-cache-up-to-5-00-ghz/specifications.html&quot;&gt;Intel i7-12700KF&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;GPU: &lt;a href=&quot;https://www.zotac.com/us/product/graphics_card/zotac-gaming-geforce-rtx-3060-ti-twin-edge&quot;&gt;Zotac Gaming GeForce RTX 3060 Ti Twin Edge&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;RAM: &lt;a href=&quot;https://www.corsair.com/us/en/p/memory/cmh32gx4m2d3600c18w/vengeance-rgb-pro-sl-32gb-2x16gb-ddr4-dram-3600mhz-c18-memory-kit-a-white-cmh32gx4m2d3600c18w&quot;&gt;Corsair Vengeance RGB Pro SL 32GB (2x16GB) DDR4 3600MHz C18&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Storage: &lt;a href=&quot;https://www.samsung.com/us/computing/memory-storage/solid-state-drives/990-pro-pcie-4-0-nvme-ssd-2tb-mz-v9p2t0b-am/&quot;&gt;Samsung 990 PRO 2TB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Motherboard: &lt;a href=&quot;https://www.gigabyte.com/Motherboard/B760I-AORUS-PRO-DDR4-rev-1x&quot;&gt;Gigabyte B760I AORUS PRO DDR4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Case + AIO + PSU: &lt;a href=&quot;https://www.coolermaster.com/catalog/max/mini-itx/nr200p-max/&quot;&gt;Cooler Master NR200P MAX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Fans: &lt;a href=&quot;https://noctua.at/en/nf-a12x15-pwm-chromax-black-swap&quot;&gt;Noctua NF-A12x15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build-process-step-by-step&quot;&gt;Build process (step by step)&lt;/h2&gt;

&lt;p&gt;All my builds start by &lt;a href=&quot;https://youtube.com/shorts/xE6erLtJ_CY&quot;&gt;testing&lt;/a&gt; the components outside the case. 
This way, I make sure the parts are in good condition, the hardware is compatible, and all components are recognized by the motherboard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/a.jpg&quot; alt=&quot;Testing the components&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.coolermaster.com/catalog/max/mini-itx/nr200p-max/&quot;&gt;Cooler Master NR200P MAX&lt;/a&gt; packaging was exceptionally good. 
Inside the case, you will find everything pre-installed and all cables and tubing neatly set in a nice arrangement.
The AIO cooler features custom 50cm tubes that are perfect for this build.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/c.jpg&quot; alt=&quot;What's inside the case&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first step is to remove the foam and untie the PSU cables.
Untying the cables is important to free the AIO cooler tubes and move the pump to the side of the case, so there’s more space for us to work with.
Next, we should install the motherboard and screw it to the case.
I highly recommend assembling the motherboard before installing it into the case.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/d.jpg&quot; alt=&quot;Installing the motherboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that all the side panels can be removed to ease the job.
After installing the motherboard, you can start connecting all the cables to it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/e.jpg&quot; alt=&quot;Installing the cooler&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I would recommend starting by the smaller ones (audio, power, reset, USB, etc).
Then, installing the cooler pump (don’t forget to remove the plastic cover!).
And finally connect the power supply cables, including CPU and motherboard connector.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/f.jpg&quot; alt=&quot;Modular power supply&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Secure everything except the PCIE cable with zip ties to the case.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/g.jpg&quot; alt=&quot;Keep it (zip) tied&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next step is to install the additional low-profile Noctua fans for extra air flow.
The fans are set in exhaust position. This will help the graphics card to stay cool.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/h.jpg&quot; alt=&quot;Installing the fans&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The last step is to install the GPU. 
The case includes a rigid extension cable to mount the GPU vertically.
There is plenty of room for our GPU, which has a relatively small footprint (at least compared to the 40xx series GPUs).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/i.jpg&quot; alt=&quot;Installing the GPU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/j.jpg&quot; alt=&quot;backside open panel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that our PSU can breath properly thanks to the case design.&lt;/p&gt;

&lt;p&gt;For the front-side panel, the case includes two panels options: a tempered glass panel and a machined aluminum panel covered in nice-looking venting slots.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/k.jpg&quot; alt=&quot;tempered glass&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;performance-and-thermals&quot;&gt;Performance and thermals&lt;/h2&gt;

&lt;p&gt;After installing Windows 10 and all the device drivers (sorry Stallman), it was time to test the performance of the system.
As expected, on synthetic loads (Cinebench R24 and Unigine Superposition) both the CPU and GPU performed extremely well.
That was to be expected, as both are high-end components.&lt;/p&gt;

&lt;p&gt;What I wasn’t expecting was that the included cooling system was able to keep the CPU from thermal throttling.
In stock configuration with the tempered glass, the thermals were the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i7-12700KF&lt;/code&gt; (under 100% load for 10’): ~96°C&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nvidia GeForce RTX 3060Ti&lt;/code&gt; (under 98% load for 10’): ~81°C&lt;/li&gt;
  &lt;li&gt;fans set to a ‘silent’ profile.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even though the components were not thermal throttling, they were still getting really hot.
The first step to decrease temps, was to increase the air flow by replacing the tempered glass panel with the aluminum one:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i7-12700KF&lt;/code&gt; (under 100% load for 10’): ~90°C&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nvidia GeForce RTX 3060Ti&lt;/code&gt; (under 98% load for 10’): ~75°C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next, I proceed to undervolt both components:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i7-12700KF&lt;/code&gt;: core voltage -0.150mV fixed offset, max boost clock 4900MHz, disable E-cores&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nvidia GeForce RTX 3060Ti&lt;/code&gt;: core voltage 925mV at 1920MHz + 700MHz memory clock &lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now the system was performing way cooler than in stock configuration:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i7-12700KF&lt;/code&gt; (under 100% load for 10’): ~78°C (-15% performance)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nvidia GeForce RTX 3060Ti&lt;/code&gt; (under 100% load for 10’): ~70°C (+5% performance)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this point I was more than pleased with the results, and I called it a day.&lt;/p&gt;

&lt;p&gt;Now, for the only negative I found with the &lt;a href=&quot;https://www.coolermaster.com/catalog/max/mini-itx/nr200p-max/&quot;&gt;Cooler Master NR200P MAX&lt;/a&gt;.
The fan on the included PSU is super noisy, and there is no easy solution to it, aside from replacing the component entirely. 
In the future, I am planning to replace the PSU with the &lt;a href=&quot;https://www.corsair.com/us/en/p/psu/cp-9020186-na/sf-series-sf750-750-watt-80-plus-platinum-certified-high-performance-sfx-psu-cp-9020186-na&quot;&gt;Corsair SF750&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.coolermaster.com/catalog/max/mini-itx/nr200p-max/&quot;&gt;Cooler Master NR200P MAX&lt;/a&gt; is a high-quality SFF case: quality materials, carefully designed, and super easy to build.
The thermals are exceptionally good.
And it has really good value.
The only part of it that I do not consider up to part, is the PSU.&lt;/p&gt;

&lt;p&gt;Overall, I am really happy with the result of this project.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/small_case/l.jpg&quot; alt=&quot;Portrait of the desk&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Disclaimer: this blog is not sponsored by any brand. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I had bad luck with the silicon lottery. Online, I saw other people achieving lower voltages on higher frequencies. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Arnau Abella</name></author><category term="PC" /><category term="Hardware" /><category term="SFF Case" /><summary type="html">I had some spare components from previous builds at home and I was wondering what I could do with them. At first, I thought about using the hardware on a new home server, but it was not a good fit for such use case due to the high power consumption parts. Then I saw my fiancé playing a video game on her Mac Book Air on the sofa — I knew it was time to give her a proper gaming PC.</summary></entry><entry><title type="html">Modding a Game Boy Advance</title><link href="http://localhost:4000/modding/2024/03/28/gba-mod/" rel="alternate" type="text/html" title="Modding a Game Boy Advance" /><published>2024-03-28T00:00:00+01:00</published><updated>2024-03-28T00:00:00+01:00</updated><id>http://localhost:4000/modding/2024/03/28/gba-mod</id><content type="html" xml:base="http://localhost:4000/modding/2024/03/28/gba-mod/">How to restore and mod a Game Boy Advance (GBA) step by step.

:--:|:--:
&lt;img src=&quot;/assets/images/gba_mod/GBA_1.jpg&quot; alt=&quot;Two modded GBA front view&quot;/&gt; | &lt;img src=&quot;/assets/images/gba_mod/GBA_2.jpg&quot; alt=&quot;Two modded GBA back view&quot;/&gt;

## Preparation

We'll need the following material:
- A donor GBA: the internals must be in good shape. The exterior state (including screen) doesn't matter because we are going to replace it.
- [3.0 Inch IPS AGB Laminated Kit: Display + Shell](https://funnyplaying.com/products/3-0-inch-ips-agb-laminated-kit)
- [GBA Li-Ion Rechargeable Battery USB-C Module](https://funnyplaying.com/products/gba-li-ion-rechargeable-battery-typec-module)
- [Clear GBA Speaker](https://funnyplaying.com/products/clear-gba-speaker)
- [GBA Replacement Silicone Pads](https://funnyplaying.com/products/replacement-silicone-pads-for-gameboy-advance) 
- [GBA Custom Buttons](https://funnyplaying.com/products/agb-custom-buttons)
- [Screwdrivers (Philips, tri-point and flathead)](https://www.ifixit.com/products/mako-driver-kit-64-precision-bits)
- Soldering iron, flux, and tin wire.
- Isopropyl alcohol 99%, brush, and microfiber cloth
- Kopton tape

## Preparing the motherboard

The first step is to retrieve the motherboard from our donor GBA. 

![GBA backside](/assets/images/gba_mod/IMG20240328123418.jpg) 

Open the back cover of your GBA by unscrewing the 6 tri-point screws and the philips screw at the bottom of the battery compartment.
I suggest using a shallowly tipped screwdriver for the philips screw, because it's quite weak and easy to strip.

The motherboard may be a little dirty at this point, but we will clean it later.

![motherboard backside](/assets/images/gba_mod/IMG20240328123732.jpg) 

The Game Boy Advance had several hardware revisions over the years, but the most relevant change for us is the connector for the display.
The `3.0 Inch IPS AGB Laminated Kit` is compatible with both a 32-pin and a 40-pin screen connector.
My GBA has revision `10 1-1` (see under the cartridge), and uses the 32-pin connector. If your revision starts with `0` that means that your GBA uses the 40-pin connector. This information will be used in a following step.

![GBA motherboard backside](/assets/images/gba_mod/IMG20240328123858.jpg) 

Next, we need to detach the display connector. Release the plastic holder by pulling up both sides and gently pull out the orange ribbon from the connector. Then, unscrew the 2 or 3 philips screws that hold the motherboard to the front shell half.

![GBA motherboard frontside](/assets/images/gba_mod/IMG20240328123943.jpg) 

Before cleaning the motherboard, we will replace the speaker with the new one.
Desolder the old one and solder in the new one.

![GBA speaker](/assets/images/gba_mod/IMG20240328124830.jpg) 

Now, we can clean all the dust and rust from the motherboard. We'll spray the motherboard with the isopropyl alcohol and brush the surface gently. Clean both sides of the motherboard. Do not worry about applying the isopropyl alcohol to the electronics, as it will evaporate while not damaging the components.

![GBA clean motherboard](/assets/images/gba_mod/IMG20240328125207.jpg) 

## Modding our GBA

The second step is to build a functional GBA on our new shell and with the IPS display.

![GBA shell](/assets/images/gba_mod/IMG20240328125355.jpg) 
![GBA IPS display](/assets/images/gba_mod/IMG20240328125641.jpg) 

First, we'll prepare our IPS display by soldering the wires that will connect to the motherboard to control the OSD menu of the display.

![GBA IPS display ribbon](/assets/images/gba_mod/IMG20240328130208.jpg)

After that, I recommend covering with Kopton tape the pins of the connector that we are not going to use. In my case, the 40-pin connector.

Next, we will remove the plastic cover from the display and install the display on our front shell.

![GBA front shell ribbon](/assets/images/gba_mod/IMG20240328132236.jpg)

Then, we will attach the display ribbon to the display board. There is a small lid that has to be open before inserting the ribbon and has to be closed afterwards. I recommend sticking the board to the display's backplate with double-sided tape. The touch sensor must be attached to the bottom of the screen with Kopton tape. Do not forget to place the holding bracket to fix the screen in place.

The next step is to solder the wires to the GBA motherboard.

![GBA wire soldering](/assets/images/gba_mod/IMG20240327155543.jpg)

The picture above is from another mod (I forgot to take pictures from the current one), but the pins to solder the wires on are the same:
**S** must be soldered to `TP2`, **L** to `TP9`, and **R** to `TP8`.

&gt; Some IPS kits require 40-pins motherboards to remove the `C54` capacitor.

![GBA back shell ribbon](/assets/images/gba_mod/IMG20240328130900.jpg)

&gt; The picture above is just an example of how the ribbon is connected to the motherboard, it is missing the folding and twisting of the ribbon.

Finally, we need to connect the 32-pin connector to the GBA motherboard. In order to do that, we have to twist the ribbon with the 32-pin connector 180°, and connect it to the GBA motherboard. 

It is now time to put the buttons and pads on their respective slots. Both are designed to only fit in a specific position and orientation. Don't forget to insert the power LED plastic diffuser.

The next step is the most challenging part of the process, so stay calm and repeat it as many times as needed.
Fold both parts by the ribbon to place the motherboard on top of the frontside shell. Make sure that the speaker is properly placed and the wires are not between the buttons and the motherboard contact pads. Using Kopton tape to fix some of the moving parts may help during the process.

![GBA motherboard mounted on front shell](/assets/images/gba_mod/IMG20240328135250.jpg) 

Screw the motherboard to the front shell and make sure everything fits by checking that the shell makes contact with the audio jack, the volume wheel and the top external connector.

![GBA backside shell closed](/assets/images/gba_mod/IMG20240328140029.jpg) 

Finally, put the remaining buttons (bumper covers, trigger buttons, and power switch cover) on the shell and put the back shell on top of it. Make sure to screw the shell so that all connectors make proper contact before testing.

Now it is a good time to test your GBA. Put the batteries back in, turn it on and test that all buttons are still working.

![GBA screen test 1](/assets/images/gba_mod/IMG20240328140729.jpg) 

You can test the touch sensor by pressing the bottom of the screen. A single-tap should increase the brightness and a long-tap should display the OSD menu (see [demo](https://www.youtube.com/shorts/IqRYh-b76Pw)).

![GBA screen test 2](/assets/images/gba_mod/IMG20240328140735.jpg) 

You can test the soldered controllers by holding 'select' for 2 seconds to display the OSD menu and using the trigger buttons to increase and decrease the different values (see [demo](https://www.youtube.com/shorts/-Ox0G2bGdoY)).

## Rechargeable battery

The final step is to replace the AA batteries compartment by a rechargeable USB-C battery.

![GBA rechargeable battery](/assets/images/gba_mod/IMG20240328140550.jpg)

First, attach the heatsink to the battery's PCB and connect the battery power connector to the board.
Then, remove the left contact from the GBA AA batteries slot. 
I used a flathead screwdriver to push from the bottom of the contact.
And finally put the rechargeable battery in the batteries compartment.
Make sure the battery cable is placed inside the left contact cavity.
Put the cover back on. You may need to adjust the battery's position a bit to make it fit in the right place so the cover can close properly.

Time to enjoy your new modded GBA!

## Resources

- Retro gaming provider: &lt;https://funnyplaying.com/&gt;
- Video guide (from another author): &lt;https://www.youtube.com/watch?v=BpX-2aeTXL4&gt;</content><author><name>Arnau Abella</name></author><category term="Modding" /><category term="Game Boy Advance" /><category term="Hardware" /><category term="Retro Gaming" /><summary type="html">How to restore and mod a Game Boy Advance (GBA) step by step.</summary></entry><entry><title type="html">Free monads in the real world</title><link href="http://localhost:4000/haskell/2022/04/19/free-interpreter/" rel="alternate" type="text/html" title="Free monads in the real world" /><published>2022-04-19T00:00:00+02:00</published><updated>2022-04-19T00:00:00+02:00</updated><id>http://localhost:4000/haskell/2022/04/19/free-interpreter</id><content type="html" xml:base="http://localhost:4000/haskell/2022/04/19/free-interpreter/">After finishing my master's degree, I applied to several companies I was interested in. During one of the selection processes, the interviewer asked me to do the following exercise:

_&quot;Write a stack-based interpreted language that includes: literals, arithmetic operations, variables, and control flow primitives. As a bonus, add asynchronous primitives such as fork and await.&quot;_

Fortunately, I was already familiar with the assignment because I implemented a [statically typed programming language](https://github.com/monadplus/CPP-lang) a year ago. Consequently, I decided to take this as a chance and do something different than the rest of the candidates. Spoiler: haskell + free monads!

&gt; The source code from this blog can be found [here](https://github.com/monadplus/free-monads-by-example). My recommendation is to have both opened side-by-side.

# Free monads

The concept of a _free monad_ comes from the field of Category Theory (CT). The [formal definition](https://ncatlab.org/nlab/show/free+monad) is hard to grasp without a background in CT. In terms of programming, a more pragmatic definition is

**Def**. For any functor $f$, there exists a _uniquely_ determined monad called the _free monad_ of the functor $f$ [^1]

In plain words, we can transform _any_ functor $f$ into a monad...And you may be wondering &quot;how is that useful to write an interpreter in Haskell? You'll see in a bit, stick with me.

## Free monads encoded in Haskell

Let's show how free monads is translated into Haskell. We are going to base our work on the encoding of free monads of the haskell package [free](https://hackage.haskell.org/package/free) by Edward Kmett. The definition is as follows:

```haskell
data Free f a = Pure a | Free (f (Free f a))
```

You can think of `Free f`  as a stack of layers `f` on top of a value `a`. 

We will encode our interpreted language as a set of free monadic actions (instructions) represented as a datatype with a functorial shape. And our programs will be just a stack of thes instructions.

The interesting part about `Free f` is that `Free f` is a [monad](https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad) as long as `f` is a [functor](https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor):

```haskell
instance Functor f =&gt; Monad (Free f) where
  return = pure
  Pure a &gt;&gt;= f = f a
  Free m &gt;&gt;= f = Free ((&gt;&gt;= f) &lt;$&gt; m)
```

This will allow us to compose programs for free[^2]. 
On top of that, do-notation gives us a nice syntax to compose 'em all!

In the next section, we will finally see how to put this into practise.

# Solving the assignment

When modeling a language[^3] using free monads, you usually divide the problem in two parts:
1. Define your language. 
2. Define the interpreter for your language.

## Defining our eDSL

First, we need to define our language. We are free to model any kind of language, but the type that represents our language must be a functor. Otherwise, our language will not be able to be composed using bind `(=&lt;&lt;)`. 

Here is the sum type representing our byte code language:

```haskell
type ByteCode = Free ByteCodeF

data ByteCodeF next
  = Lit Value next
  | Load Var next
  | Write Var next
  | BinaryOp OpCode next
  | Loop (ByteCode Bool) (ByteCode ()) next
  | Ret (Value -&gt; next)
  | NewChan (Channel -&gt; next)
  | Send Channel next
  | Recv Channel next
  | Fork (ByteCode ()) (Future () -&gt; next)
  | Await (Future ()) next
  deriving (Functor)

data Value
  = B Bool
  | I Integer
  deriving stock (Eq, Show, Ord)

newtype Chan a = Chan { getChan :: MVar a}
  deriving newtype (Eq)

data Future a where
  Future :: Exception e =&gt; Async (Either e a) -&gt; Future a
```

- `Lit` instruction to instantiate literals (integer and boolean values).
- `Load`/`Write` instructions to load and write variables, respectively.
- `BinaryOp` instruction to apply binary operations (+, *, &lt;) on the top values of the stack.
- `Loop` instruction to execute a set of instructions iteratively based on a certain condition.
- `Ret` instruction to stop the program and return the value on top of the stack.
- `Fork`/`Await` instructions to start and await an asynchronous program, respectively.
- `NewChan`/`Send`/`Recv` instructions to create a new asynchronous channel, send and receive a value through the channel, respectively. This channel allow to independent asynchronous programs to communicate.

The careful reader may have notice that our type `ByteCodeF` has a type parameter `next :: Type`. This type parameter is required for `ByteCodeF` to be a functor. We can think of `next` as the next instruction in our program. In fact, when we interpret the `ByteCode` free monad, next will be replaced by the (evaluated) next instruction of our program.

Next, for each constructor of our `ByteCodeF`, we need a function that lifts `ByteCodeF` into `ByteCode`. For example, here is the definition of that function for `Lit`:

```haskell
lit :: Value -&gt; ByteCode ()
lit v = Free (Lit v (Pure ()))
```

Implementing this for each constructor is tedious and error prone. This problem can be solved with metaprogramming. In particular, with [template haskell](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH.html) (for an introduction to template haskell see my [blog post](https://monadplus.pro/haskell/2021/10/14/th/)). Fortunately, this is already implemented in [Control.Monad.Free.TH](https://hackage.haskell.org/package/free-5.1.7/docs/Control-Monad-Free-TH.html). 

Therefore, we are going to use `makeFree` to automatically derive all these free monadic actions

```haskell
$(makeFree ''ByteCodeF)
```

which generates the following code[^4]

```haskell
lit      :: Value                         -&gt; ByteCode ()
load     :: Var                           -&gt; ByteCode ()
write    :: Var                           -&gt; ByteCode ()
loop     :: ByteCode Value -&gt; ByteCode () -&gt; ByteCode ()
newChan  ::                                  ByteCode Channel
send     :: Channel                       -&gt; ByteCode ()
recv     :: Channel                       -&gt; ByteCode ()
fork     :: ByteCode ()                   -&gt; ByteCode (Async ())
await    :: Async ()                      -&gt; ByteCode ()
```

Once we have the basic building blocks of our language, we can start building programs by composing smaller programs using monadic composition!

```haskell
loopN :: Integer -&gt; ByteCode ()
loopN until = do
  let {n = &quot;n&quot;; i = &quot;i&quot;}
  litI until
  write n
  litI 1
  write i
  loop (i &lt; n) (i ++)

(&lt;) i n = do
  load n
  load i
  lessThan
  ret
  
(++) i = do
  litI 1
  load i
  add
  write i
```

## Interpreting our program

Now that we have the building blocks to construct our domain specific programs, it is only remaining to implement an interpreter to evaluate this embedded DSL in our host language Haskell.

The interpreter is usually implemented using [iterM](https://hackage.haskell.org/package/free-5.1.7/docs/Control-Monad-Free.html#v:iterM), which allows us to collapse our `Free f` into a monadic value `m a` by providing a function `f (m a) -&gt; m a` (usually called an _algebra_) that operates on a single layer of our free monad. If you are familiar with recursion schemes, `iterM` is a specialization of [cataA](https://hackage.haskell.org/package/recursion-schemes-5.2.2.2/docs/Data-Functor-Foldable.html#v:cataA). This may sound confusing at first, but it is easier than it sounds.

First of all, we need to choose the monadic value `m`. For our interpreted language, we choose `m ~ Interpreter`

```haskell
newtype Interpreter a = Interpreter 
  { runInterpreter :: StateT Ctx (ExceptT Err IO) a }

data Ctx = Ctx
  { stack :: [Value],
    variables :: Map Var Value
  }

data Err
  = VariableNotFound Var
  | StackIsEmpty
  | BinaryOpExpectedTwoOperands
  | AsyncException Text
  | WhoNeedsTypes
```

where `Ctx` is the current context of our program i.e. the state of the stack and the memory registers. 
Then, we specialize `iterM` to our example

```haskell
--       &lt;---------------- algebra -----------------&gt;
iterm :: (ByteCodeF (Interpreter a) -&gt; Interpreter a) -&gt; ByteCode a -&gt; Interpreter a
```

The last step and usually the most difficult one is to implement the _algebra_ of our DSL

```haskell
algebra :: ByteCodeF (Interpreter a) -&gt; Interpreter a
algebra = \case
  Ret f -&gt; popI &gt;&gt;= f
  Lit i k -&gt; pushI i &gt;&gt; k
  Load var k -&gt; loadI var &gt;&gt;= pushI &gt;&gt; k
  Write var k -&gt; popI &gt;&gt;= storeI var &gt;&gt; k
  BinaryOp op k -&gt;
    do
      catchError
        (liftA2 (applyOp op) popI popI &gt;&gt;= either throwError pushI)
        ( \case
            StackIsEmpty -&gt; throwError BinaryOpExpectedTwoOperands
            e -&gt; throwError e
        )
      &gt;&gt; k
  Loop cond expr k -&gt;
    fix $ \rec -&gt; do
      b &lt;- interpret cond
      if b
        then interpret expr &gt;&gt; rec
        else k
  NewChan f -&gt;
    liftIO getChan &gt;&gt;= f
  Send chan k -&gt;
    popI &gt;&gt;= (liftIO . sendChan chan) &gt;&gt; k
  Recv chan k -&gt;
    liftIO (recvChan chan) &gt;&gt;= pushI &gt;&gt; k
  Fork branch k -&gt;
    future branch &gt;&gt;= k
  Await (Future async') k -&gt; do
    ea &lt;- liftIO $ waitCatch async'
    case ea of
      Left (SomeException ex) -&gt; throwError (AsyncException (T.pack $ show ex))
      Right (Left ex) -&gt; throwError (AsyncException (T.pack $ show ex))
      Right _r -&gt; k
```

Finally, we combine `iterM` and `algebra` to obtain

```haskell
interpret :: ByteCode a -&gt; Interpreter a
interpret = iterM algebra
```

which allow us to _interpret_ our embedded language in our host language. The result of `interpret` can be composed with other effectful programs and it can also be evaluated using `runByteCode`:

```haskell
runByteCode :: ByteCode a -&gt; Either Err a
runByteCode = unsafePerformIO . runExceptT . flip evalStateT emptyCtx . runInterpreter . interpret
```

## All together

So far, we have built the following components:
1. An (embedded) stack-based language in Haskell with primitives like: `lit`, `load`, `write`, `loop` ...
2. An interpreter for that language: `interpret` and `runByteCode`.

Now that we have all the ingredients to create embedded stack-based programs and interpret them, we can put this into practise. 

```haskell
program :: ByteCode Value
program = do
  chan1 &lt;- newChan
  chan2 &lt;- newChan
  _ &lt;- fork $ do
    loopN 100000
    litI 1
    send chan1
  _ &lt;- fork $ do
    loopN 100000
    litI 1
    send chan2
  loopN 10
  recv chan1
  recv chan2
  add
  ret

main :: IO ()
main = case runByteCode program of
  Left err -&gt; throw err
  Right res -&gt; putStrLn $ &quot;Result = &quot; &lt;&gt; show res
```

The following `program` creates two asynchronous tasks that after a period of time, return the integer `1` through an asynchronous channel. The main program waits for these two asynchronous tasks to finish and outputs the sum of the results of the asynchronous tasks.

# Conclusion

In this post, we have introduced free monads and how they can be used to implement embedded domain specific languages. In particular, we have seen how to embed a stack-based language in Haskell. To see other examples of domain specific languages, we refer the reader to the [examples of the free package](https://github.com/ekmett/free/tree/master/examples).

This post only covered a half of the [free](https://hackage.haskell.org/package/free) package. In the next post of this series, we'll explore the other half: church encoding, applicative free, cofree...

[^1]: The term &quot;free&quot; in the context of CT refers to the fact that we have not added structure to the original object. Don't confuse the term with the adjective free: &quot;costing nothing&quot;.

[^2]: Pun intended.

[^3]: Technically you are defining an embedded domain specific language (eDSL).

[^4]: The actual signatures use [MonadFree](https://hackage.haskell.org/package/free-5.1.7/docs/Control-Monad-Free.html#t:MonadFree) which is an mtl-style class that allow us to compose [FreeT](https://hackage.haskell.org/package/free-5.1.7/docs/Control-Monad-Trans-Free.html#t:FreeT) with other monad transformers. We were able to monomorphize the return value `MonadFree f m =&gt; m ~ Free ByteCodeF` thanks to the instance `Functor f =&gt; MonadFree f (Free f)`.</content><author><name>Arnau Abella</name></author><category term="haskell" /><category term="free monads" /><category term="eDSL" /><summary type="html">After finishing my master’s degree, I applied to several companies I was interested in. During one of the selection processes, the interviewer asked me to do the following exercise:</summary></entry><entry><title type="html">Template Haskell; Use Cases</title><link href="http://localhost:4000/haskell/2021/10/14/th/" rel="alternate" type="text/html" title="Template Haskell; Use Cases" /><published>2021-10-14T00:00:00+02:00</published><updated>2021-10-14T00:00:00+02:00</updated><id>http://localhost:4000/haskell/2021/10/14/th</id><content type="html" xml:base="http://localhost:4000/haskell/2021/10/14/th/"># Introduction

_Template Haskell_ (TH) is an extension of [GHC](https://www.haskell.org/ghc/) that allows the user to do type-safe compile-time meta-programming in _Haskell_. The idea behind template haskell comes from the paper [&quot;Template Meta-programming for Haskell&quot;](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/meta-haskell.pdf) by S.P. Jones and T. Sheard. Template Haskell was shipped with [GHC version 6.0](https://www.haskell.org/ghc/download_ghc_600.html). The compiler extension has evolved a lot since 2003 and its current state is well described at the [GHC: User Manual](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html) and [template-haskell](https://hackage.haskell.org/package/template-haskell) package.

Initially, TH offered the ability to generate code at compile time and allowed the programmer to manipulate the _abstract syntax tree_ (AST) of the program. The addition of new capabilities such as [lifting](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift), [TExp](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH.html#t:TExp) , [runIO](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Syntax.html#v:runIO), and [quasiquoting](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Quote.html) opened a bunch of new use cases to explore.

In this blog post, we are going explore a bunch of interesting Template Haskell's use cases:

- Type Class Derivation
- N-ary Function Generation
- Compile-time Static Input Validation
- Arbitrary IO at Compile Time

This article assumes some familiarity with Haskell and, in particular, with Template Haskell. There are many well-written tutorials on the internet such as [A Practical Template Haskell Tutorial](https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial) or [Template Haskell Tutorial](https://markkarpov.com/tutorial/th.html).  We strongly recommend reading the previously mentioned tutorials before continuing with the reading.

# Use Cases

Before we start, these are the list of _language extensions_ and _imports_ that we are going to use in the following sections:

```haskell
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ViewPatterns #-}
```

```haskell
import Codec.Picture
import Control.Applicative (ZipList (..))
import Control.Monad (replicateM, when)
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import Data.Char (isSpace)
import Data.Data hiding (cast)
import Data.Foldable
import qualified Data.Text as T
import Data.Word
import Instances.TH.Lift ()
import Language.Haskell.TH
import Language.Haskell.TH.Quote
import Language.Haskell.TH.Syntax
import Network.HTTP.Req
import Text.Read (readMaybe)
import qualified Text.URI as URI
```

## Ex 1: Type Class Derivation

Automatic derivation of type class instances is one of many problems that TH can solve. Although this problem can also be solved by [generics](https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Generics.html), the compilation times are usually longer. For this reason, template haskell is still the preferred way to generate type class instances at compile time.

Here we present an example of how to derive the type class [Foldable](https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable) for arbitrary datatypes.

```haskell
data List a 
  = Nil 
  | Cons a (List a)
deriveFoldable ''List
```

The implementation is as follows:

```haskell
data Deriving = Deriving { tyCon :: Name, tyVar :: Name }
  deriving (Typeable)

deriveFoldable :: Name -&gt; Q [Dec]
deriveFoldable ty = do
  (TyConI tyCon) &lt;- reify ty
  (tyConName, tyVars, cs) &lt;- case tyCon of
    DataD _ nm tyVars _ cs _   -&gt; return (nm, tyVars, cs)
    NewtypeD _ nm tyVars _ c _ -&gt; return (nm, tyVars, [c])
    _ -&gt; fail &quot;deriveFoldable: tyCon may not be a type synonym.&quot;

  let (KindedTV tyVar StarT) = last tyVars
  putQ $ Deriving tyConName tyVar

  let instanceType = conT ''Foldable `appT` foldl' apply (conT tyConName) (init tyVars)
  foldableD &lt;- instanceD (return []) instanceType [genFoldMap cs]
  return [foldableD]

  where
    apply t (PlainTV name)    = appT t (varT name)
    apply t (KindedTV name _) = appT t (varT name)

genFoldMap :: [Con] -&gt; Q Dec
genFoldMap cs = funD 'foldMap (genFoldMapClause &lt;$&gt; cs)

genFoldMapClause :: Con -&gt; Q Clause
genFoldMapClause (NormalC name fieldTypes)
  = do f          &lt;- newName &quot;f&quot;
       fieldNames &lt;- replicateM (length fieldTypes) (newName &quot;x&quot;)

       let pats = varP f : [conP name (map varP fieldNames)]
           newFields = newField f &lt;$&gt; zip fieldNames (snd &lt;$&gt; fieldTypes)
           body = normalB $
             foldl' (\ b x -&gt; [| $b &lt;&gt; $x |]) (varE 'mempty) newFields

       clause pats body []
genFoldMapClause _ = error &quot;Not supported yet&quot;

newField :: Name -&gt; (Name, Type) -&gt; ExpQ
newField f (x, fieldType) = do
  Just (Deriving typeCon typeVar) &lt;- getQ
  case fieldType of
    VarT typeVar' | typeVar' == typeVar -&gt;
      [| $(varE f) $(varE x) |]

    AppT ty (VarT typeVar') | leftmost ty == ConT typeCon &amp;&amp; typeVar' == typeVar -&gt;
        [| foldMap $(varE f) $(varE x) |]

    _ -&gt; [| mempty |]
    
leftmost :: Type -&gt; Type
leftmost (AppT ty1 _) = leftmost ty1
leftmost ty           = ty
```

## Ex 2: N-ary Function Generation

Have you ever written a function like `snd3 :: (a, b, c) -&gt; b` or `snd4 :: (a, b, c, d) -&gt; b` ? Then, you can do better by letting the compiler write those boilerplate and error-prone functions for you.

Here we present an example of how to write an arbitrary-sized [zipWith](https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-OldList.html#v:zipWith). 
We have chosen `zipWith` since it is a fairly simple function but complex enough to be used as the base to write more complex functions.

Here is a first implementation of `zipWithN`:

```haskell
zipWithN :: Int -&gt; Q [Dec]
zipWithN n
  | n &gt;= 2 = sequence [funD name [cl1, cl2]]
  | otherwise = fail &quot;zipWithN: argument n may not be &lt; 2.&quot;
  where
    name = mkName $ &quot;zipWith&quot; ++ show n

    cl1 = do
      f &lt;- newName &quot;f&quot;
      xs &lt;- replicateM n (newName &quot;x&quot;)
      yss &lt;- replicateM n (newName &quot;ys&quot;)
      let argPatts = varP f : consPatts
          consPatts = [ [p| $(varP x) : $(varP ys) |]
                      | (x, ys) &lt;- xs `zip` yss
                      ]
          apply = foldl (\ g x -&gt; [| $g $(varE x) |])
          first = apply (varE f) xs
          rest = apply (varE name) (f:yss)
      clause argPatts (normalB [| $first : $rest |]) []

    cl2 = clause (replicate (n+1) wildP) (normalB (conE '[])) []
```

This implementation works fine but the compiler will `warn` you about a missing signature on a top-level definition.
In order to fix this, we need to add a type signature to the generated term:

```haskell
zipWithN :: Int -&gt; Q [Dec]
zipWithN n
  | n &gt;= 2 = sequence [ sigD name ty, funD name [cl1, cl2] ]
  ...
  where
    ...

    ty = do
      as &lt;- replicateM (n+1) (newName &quot;a&quot;)
      let apply = foldr (appT . appT arrowT)
          funTy = apply (varT (last as)) (varT &lt;$&gt; init as)
          listsTy = apply (appT listT (varT (last as))) (appT listT . varT &lt;$&gt; init as)
      appT (appT arrowT funTy) listsTy
    
    ...
```

Now you can use `zipWithN` to generate arbitrary-sized `zipWith` functions:

```haskell
...
$(zipWithN 6)
$(zipWithN 7)
$(zipWithN 8)
...
```

Manually generating each instance partially defeats the purpose of `zipWithN`.
In order to address this issue, we need the auxiliary function `genZipWith`. Notice, we will use an alternative simplified definition of `zipWithN` that exploits slicing and lifting to showcase.

```haskell
genZipWith :: Int -&gt; Q [Dec]
genZipWith n = traverse mkDec [1..n]
  where
    mkDec ith = do
      let name = mkName $ &quot;zipWith&quot; ++ show ith ++ &quot;'&quot;
      body &lt;- zipWithN ith
      return $ FunD name [Clause [] (NormalB body) []]

zipWithN :: Int -&gt; Q Exp
zipWithN n = do
    xss &lt;- replicateM n (newName &quot;xs&quot;)
    [| \f -&gt;
        $(lamE (varP &lt;$&gt; xss)
                [| getZipList
                    $(foldl'
                        (\ g xs -&gt; [| $g &lt;*&gt; $xs |])
                        [| pure f |]
                        (fmap (\xs -&gt; [| ZipList $(varE xs) |]) xss)
                    )
                |])
    |]
```

Now, we can generate arbitrary sized `zipWith` functions

```haskell
$(genZipWith' 20)
```

which will produce `zipWith1`, `zipWith2`, ..., `zipWith19`, `zipWith20`.

## Ex 3: Compile-time Input Validation

Static input data is expected to be &quot;correct&quot; on a strongly typed programming language. 
For example, assigning the decimal number `256` to a variable of type `Byte` is expected to fail at compile time.
So, let's try it on Haskell:

```
ghci&gt; :m +Data.Word
ghci&gt; 256 :: Word8
&lt;interactive&gt;:2:1: warning: [-Woverflowed-literals]
    Literal 256 is out of the Word8 range 0..255
0
```

Ops! Indeed, the code has compiled with an unexpected overflow. 
The keen-eyed reader may be thinking that this bug could have been prevented with the appropriate GHC flags `-Wall` and `-Werror`.
Here we present a more general approach to validate static input data from the user using [quasiquoting](https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Quote.html). This example can be easily adapted to all sorts of input data.

```haskell
word :: QuasiQuoter
word = QuasiQuoter
  { quoteExp  = parseWord
  , quotePat  = notHandled &quot;patterns&quot;
  , quoteType = notHandled &quot;types&quot;
  , quoteDec  = notHandled &quot;declarations&quot;
  }
  where notHandled things = error $
          things ++ &quot; are not handled by the word quasiquoter.&quot;

parseWord :: String -&gt; Q Exp
parseWord (trim -&gt; str) =
  case words str of
    [w] -&gt;
      case break (== 'u') w of
        (lit, size) -&gt;
          case readMaybe @Integer lit of
            Just int -&gt; do
              when (int &lt; 0) $ fail &quot;words are strictly positive&quot;
              case size of
                &quot;u8&quot; -&gt; castWord @Word8 ''Word8 int
                &quot;u16&quot; -&gt; castWord @Word16 ''Word16 int
                &quot;u32&quot; -&gt; castWord @Word32 ''Word32 int
                &quot;u64&quot; -&gt; castWord @Word64 ''Word64 int
                _ -&gt; fail (&quot;size &quot; &lt;&gt; size &lt;&gt; &quot; is not one of {u8, u16, u32, u64}&quot;)
            Nothing -&gt; fail (lit &lt;&gt; &quot; cannot be parsed as Integer&quot;)

    _ -&gt; fail (&quot;Unexpected word: &quot; &lt;&gt; str)
  where
    castWord :: forall a. (Show a, Bounded a, Integral a) =&gt; Name -&gt; Integer -&gt; ExpQ
    castWord ty int
      | int &lt;= fromIntegral (maxBound @a) = sigE [|int|] (conT ty)
      | otherwise = fail (pprint ty &lt;&gt; &quot; is outside of bound: [0,&quot; &lt;&gt; show (maxBound @a) &lt;&gt; &quot;]&quot;)

trim :: String -&gt; String
trim = f . f where
  f = reverse . dropWhile isSpace
```

The `word` quasiquoter can validate static input data 

```
ghci&gt; [word| 255u8 |]
255 :: Word8
```

and emit a compilation-time error if the data is not valid

```
ghci&gt; [word| 256u8 |]
&lt;interactive&gt;:315:7-15: error:
    * GHC.Word.Word8 is outside of bound: [0,255]
    * In the quasi-quotation: [word| 256u8 |]
```

## Ex 4: Arbitrary IO at Compile Time

Running arbitrary IO on compile-time is one of the features of TH. This allows the user to make compilation dependant on external conditions such as the database schema, the current git branch or a local file content.

In this last example, we are going to use `runIO` and `quasiquoting` to get static pictures from remote and local files at compile-time. Notice, this example has been simplified to avoid all the overhead of proper error handling.

1. Try to parse the input string as an _url_
  1. If it succeeds, request the content of the url as a bytestring
  2. Otherwise, interpret the input string as a _file path_ and read its content.
2. Decode the contents as a  [DynamicImage](https://hackage.haskell.org/package/JuicyPixels-3.3.6/docs/Codec-Picture.html#t:DynamicImage)
3. Lift the `DynamicImage`

```haskell
img :: QuasiQuoter
img = QuasiQuoter {
    quoteExp  = imgExpQ
  , quotePat  = notHandled &quot;patterns&quot;
  , quoteType = notHandled &quot;types&quot;
  , quoteDec  = notHandled &quot;declarations&quot;
  }
  where notHandled things = error $
          things ++ &quot; are not handled by the img quasiquoter.&quot;

imgExpQ :: String -&gt; ExpQ
imgExpQ str = do
  uri' &lt;- URI.mkURI (T.pack str)
  bs &lt;- runIO $ do
    (bs, dynImg) &lt;- 
      case useURI uri' of
        Nothing -&gt; BS.readFile str
        Just (Left (url, _)) -&gt; requestBs url
        Just (Right (url, _)) -&gt; requestBs url
    either fail (pure . (bs,)) $ decodeImage bs
  liftDynamicImage bs

liftDynamicImage :: ByteString -&gt; Q Exp
liftDynamicImage bs = [| either error id (decodeImage bs) |]

requestBs :: Url scheme -&gt; IO ByteString
requestBs url =
  runReq defaultHttpConfig $ do
    r &lt;- req
            GET
            url
            NoReqBody
            bsResponse
            mempty
    return (responseBody r)
```

The `img` quasiquoter can be used to load pictures as static data inside your binary

```haskell
dynImg1 :: DynamicImage
dynImg1 = [img|https://httpbin.org/image/jpeg|]

dynImg2 :: DynamicImage
dynImg2 = [img|./resources/pig.png|]
```

# Conclusion

During this blog post, we have seem some of the use cases of template haskell and how to implement them.
We encourage the reader to use our examples to build new and more compelling use cases of template haskell and to share them with the community.

We hope you enjoyed this post and don't forget to share your own use cases for template haskell in the comments.</content><author><name>Arnau Abella</name></author><category term="haskell" /><category term="template-haskell" /><category term="meta-programming" /><summary type="html">Introduction</summary></entry><entry><title type="html">The Fizz Buzz problem</title><link href="http://localhost:4000/haskell/2021/09/24/fizz-buzz/" rel="alternate" type="text/html" title="The Fizz Buzz problem" /><published>2021-09-24T00:00:00+02:00</published><updated>2021-09-24T00:00:00+02:00</updated><id>http://localhost:4000/haskell/2021/09/24/fizz-buzz</id><content type="html" xml:base="http://localhost:4000/haskell/2021/09/24/fizz-buzz/">This morning, I saw [this blog](https://twitter.com/cercerilla/status/1441994898870177796?s=20) by [@cercerilla](https://twitter.com/cercerilla/) on twitter. I was fascinated by her implementation but I couldn't believe how many lines of code it took to write such a simple program! The _Fizz Buzz_ problem can be implemented on the term level with only a few lines of code:

```haskell
fizz :: Int -&gt; String
fizz n | n `mod` 15 == 0  = &quot;FizzBuzz&quot;
       | n `mod` 3  == 0  = &quot;Fizz&quot;
       | n `mod` 5  == 0  = &quot;Buzz&quot;
       | otherwise        = show n

main :: IO()
main = traverse_ (putStrLn . fizz) [1..100]
```

One of the main problems of type-level programming in Haskell is that you cannot implement higher-order functions on the type level (see [saturation restriction](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0242-unsaturated-type-families.rst#recap-saturation-restriction)). Therefore, we cannot abstract as much as we do on the term level using `traverse` and `[1..100]`. There is an accepted proposal [unsaturated type families](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0242-unsaturated-type-families.rst) but it still not merged into GHC.

Are we doomed to write a lot of boilerplate code as in `@cercerilla` example? The answer is no, there is a workaround to this problem called _defunctionalization_. Defunctionalization translates higher-order functions into first-order functions:

1. Instead of working with functions, work with symbols representing functions.
2. Build your final functions and values by composing and combining these symbols.
3. At the end of it all, have a single `apply` function interpret all of your symbols and produce the value you want.

This idea of defunctionalization is implemented in the [singletons](https://hackage.haskell.org/package/singletons) and in [first-class-families](https://hackage.haskell.org/package/first-class-families).

Below we present the implementation of _Fizz Buzz_ on the type-level using the `singletons` library(you can achieve a similar result using `fcf` package). The implementation is many times smaller than the one implemented using ad hoc higher-order combinators and easier to understand since most of the complexity is moved away to the singletons' library.

```haskell
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE GADTs #-}

module FizzBuzz where

import Data.Singletons.TH
import Data.Singletons.Prelude
import Data.Singletons.TypeLits

$(singletons [d|
  type Divisible n by = Mod n by == 0

  type FizzBuzzElem :: Nat -&gt; Symbol
  type FizzBuzzElem n =
      If
        (Divisible n 15)
        &quot;FizzBuzz&quot;
        ( If
            (Divisible n 3)
            &quot;Fizz&quot;
            ( If
                (Divisible n 5)
                &quot;Buzz&quot;
                (Show_ n)))

  |])

type FizzBuzz n = Fmap FizzBuzzElemSym0 (EnumFromTo 1 n)

-- |
-- &gt;&gt;&gt; fizzBuzz @10
-- &quot;[FizzBuzz,1,2,Fizz,4,Buzz,Fizz,7,8,Fizz]&quot;
fizzBuzz :: forall (n :: Nat). (KnownSymbol (Show_ (FizzBuzz n))) =&gt; String
fizzBuzz = symbolVal (Proxy @(Show_ (FizzBuzz n)))
```

Type-level programming in Haskell is still a difficult task since the support for higher-order abstractions is still not available in the language. With the use of libraries such as `singletons` we can make this task less difficult reusing many higher-order abstractions on the type level.</content><author><name>Arnau Abella</name></author><category term="haskell" /><category term="type-level programming" /><summary type="html">This morning, I saw this blog by @cercerilla on twitter. I was fascinated by her implementation but I couldn’t believe how many lines of code it took to write such a simple program! The Fizz Buzz problem can be implemented on the term level with only a few lines of code:</summary></entry><entry><title type="html">Running a Haskell Script without GHC</title><link href="http://localhost:4000/haskell/nix/2020/03/10/running-haskell-scripts/" rel="alternate" type="text/html" title="Running a Haskell Script without GHC" /><published>2020-03-10T00:00:00+01:00</published><updated>2020-03-10T00:00:00+01:00</updated><id>http://localhost:4000/haskell/nix/2020/03/10/running-haskell-scripts</id><content type="html" xml:base="http://localhost:4000/haskell/nix/2020/03/10/running-haskell-scripts/"># Introduction

Given the following haskell script `generate-random-samples.hs` that requires [mwc-random](https://hackage.haskell.org/package/mwc-random-0.14.0.0)

```haskell
{-# LANGUAGE ScopedTypeVariables #-}

import System.Random.MWC
import Data.Vector.Unboxed
import Control.Monad.ST

main = do
  vs &lt;- withSystemRandom $
        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)
  print vs
```

... how do you run it without having to globally install the package or having to build a whole cabal project ?

# Initial approach

One of the simplest approaches using nix is the following:

```bash
$ nix-shell --packages 'haskellPackages.ghcWithHoogle (pkgs: with pkgs; [ mwc-random ])'
nix-shell&gt; runghc generate-random-samples.hs
```

In order to reuse the command so other people can run the script, you can add the following `shell.nix`:

```nix
{ compiler ? &quot;ghc881&quot; }:
let

  pkgs = import (builtins.fetchGit {
    url = &quot;https://github.com/NixOS/nixpkgs.git&quot;;
    rev = &quot;890440b0273caab258b38c0873c3fe758318bb4f&quot;;
    ref = &quot;master&quot;;
  }) {};

  ghc = pkgs.haskell.packages.${compiler}.ghcWithPackages (ps: with ps; [
          mwc-random
        ]);

in

pkgs.stdenv.mkDerivation {
  name = &quot;ghc-env&quot;;
  buildInputs = [ ghc pkgs.cabal-install ];
  shellHook = &quot;eval $(egrep ^export ${ghc}/bin/ghc)&quot;;
}
```

So now you only need to call `$ nix-shell` to enter into a pure shell with a specific GHC version that includes all your dependencies:

```bash
$ nix-shell
nix-shell&gt; runghc generate-random-samples.hs
```

# Improving the first approach

The only __issue__ is that you must be aware of __how nix work__ in order to be able to run the script.

But these could be solved using bash _shebangs_ in your haskell script:

```haskell
#!/usr/bin/env nix-shell
#!nix-shell -i runghc
{-# LANGUAGE ScopedTypeVariables #-}

import System.Random.MWC
import Data.Vector.Unboxed
import Control.Monad.ST

main = do
  vs &lt;- withSystemRandom $
        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)
  print vs
```

So now, you can run your haskell script in an environment without ghc:

```bash
./generate-random-samples.hs
[6052359640365008112,3693984866634705670,6521947999724514858,640433474764908030,-4262896110044960033,-1795671341099353119,-2220462704949887998,-248182841640258167,709016591698961687,-3622504171575206589,5987258113070378446,-159251391303273987,-8449937247808153766,6165509553180365166,-8199532339362621783,-9187765480154042269,-2389922548196927048,-4842141643835297495,-1106748185069026877,826927505518387091]
```

# Update: 11-03-2020

After reading the following [comment in reddit](https://www.reddit.com/r/haskell/comments/fgdngc/running_a_haskell_script_without_ghc_using_nix/fk56fut/), I think it is worth mentioning that you can achieve _better modularity_ in exchange of _maintainability_, by having everything on the haskell script, without having to depend on a `shell.nix` file:

```haskell
#!/usr/bin/env nix-shell
#!nix-shell -i runghc -p &quot;haskellPackages.ghcWithPackages (pkgs: with pkgs; [ mwc-random ])&quot;
#!nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/d373d80b1207d52621961b16aa4a3438e4f98167.tar.gz
{-# LANGUAGE ScopedTypeVariables #-}

import System.Random.MWC
import Data.Vector.Unboxed
import Control.Monad.ST

main = do
  vs &lt;- withSystemRandom $
        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)
  print vs
```</content><author><name>Arnau Abella</name></author><category term="haskell" /><category term="nix" /><summary type="html">Introduction</summary></entry></feed>