<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Free monads in the real world]]></title>
      <url>/haskell/2022/04/19/free-interpreter/</url>
      <content type="text"><![CDATA[After finishing my master’s degree, I applied to several companies I was interested in. During one of the selection processes, the interviewer asked me to do the following exercise:“Write a stack-based interpreted language (byte code) that includes: literals, arithmetic operations, variables, and control flow primitives. As a bonus, add asynchronous primitives such as fork and await.”Fortunately, I was already familiar with the assignment because I implemented a statically typed programming language a year ago. Consequently, I decided to take this as a chance and do something than the rest of the candidates. Spoiler: free monads!Free monadsThe concept of free monad comes from the field of category theory (CT). The formal definition requires a strong background in CT. So, to keep this pragmatic, we are going to consider the following definition:  For any functor $f$, there exists a uniquely determined monad called the free monad of the functor $f$.Probably this definition is still too general, so let’s see how this is translated into Haskell. In particular, we are going to base our work on the encoding of free monads of the haskell package free by Edward Kmett et al. The definition is as follows:data Free f a = Pure a | Free (f (Free f a))Free f is simply a stack of layers f on top of a value a.The interesting part about Free f is that Free f is a monad as long as f is a functor (this is why it is called free, because you get a monad for free).instance Functor f =&gt; Monad (Free f) where  return = pure  Pure a &gt;&gt;= f = f a  Free m &gt;&gt;= f = Free ((&gt;&gt;= f) &lt;$&gt; m)This will allow us to compose free actions by embedding new layers on the bottom of the stack of layers, which is essential to model domain specific languages.In practise, the user builds a free monad stacking layers of their domain specific language modelled as a functor. Later, it executes iter (or its corresponding applicative and monadic version) to interpret and collapse each layer into a single (effectful) value.iter :: Functor f =&gt; (f a -&gt; a) -&gt; Free f a -&gt; aiterA :: (Applicative p, Functor f) =&gt; (f (p a) -&gt; p a) -&gt; Free f a -&gt; p a iterM :: (Monad m, Functor f) =&gt; (f (m a) -&gt; m a) -&gt; Free f a -&gt; m a In the next section, we will see how to put that into practise.Solving the assignmentWhen modeling an embedded domain specific language (eDSL) using free monads, you usually divide the problem in two parts:  Define your language.  Define the interpreter for your language.Defining our eDSLFirst, we need to define our language. We are free to model any kind of language, but the type that represents our language must be a functor. Otherwise, our language will not be able to be composed using bind (=&lt;&lt;).Here is the sum type representing our byte code language:type ByteCode = Free ByteCodeFdata ByteCodeF next  = Lit Value next  | Load Var next  | Write Var next  | BinaryOp OpCode next  | Loop (ByteCode Bool) (ByteCode ()) next  | Ret (Value -&gt; next)  | NewChan (Channel -&gt; next)  | Send Channel next  | Recv Channel next  | Fork (ByteCode ()) (Future () -&gt; next)  | Await (Future ()) next  deriving stock (Functor)data Value  = B Bool  | I Integer  deriving stock (Eq, Show, Ord)newtype Chan a = Chan { getChan :: MVar a}  deriving newtype (Eq)data Future a where  Future :: Exception e =&gt; Async (Either e a) -&gt; Future a  Lit instruction to instantiate literals (integer and boolean values).  Load/Write instructions to load and write variables, respectively.  BinaryOp instruction to apply binary operations (+, *, &lt;) on the top values of the stack.  Loop instruction to execute a set of instructions iteratively based on a certain condition.  Ret instruction to stop the program and return the value on top of the stack.  Fork/Await instructions to start and await an asynchronous program, respectively.  NewChan/Send/Recv instructions to create a new asynchronous channel, send and receive a value through the channel, respectively. This channel allow to independent asynchronous programs to communicate.The careful reader may have notice that our type ByteCodeF has a type parameter next :: Type. This type parameter is required for ByteCodeF to be a functor. We can think of next as the next instruction in our program. In fact, when we interpret the ByteCode free monad, next will be replaced by the (evaluated) next instruction of our program.Next, for each constructor of our ByteCodeF, we need a function that lifts ByteCodeF into ByteCode. For example, here is the definition of that function for Lit:lit :: Value -&gt; ByteCode ()lit v = Free (Lit v (Pure ()))Implementing this for each constructor is tedious and error prone. This problem can be solved with metaprogramming. In particular, with template haskell (for an introduction to template haskell see my blog post). Fortunately, this is already implemented in Control.Monad.Free.TH.Therefore, we are going to use makeFree to automatically derive all these free monadic actions$(makeFree ''ByteCodeF)which generates the following codelit      :: Value                         -&gt; ByteCode ()load     :: Var                           -&gt; ByteCode ()write    :: Var                           -&gt; ByteCode ()loop     :: ByteCode Value -&gt; ByteCode () -&gt; ByteCode ()newChan  ::                                  ByteCode Channelsend     :: Channel                       -&gt; ByteCode ()recv     :: Channel                       -&gt; ByteCode ()fork     :: ByteCode ()                   -&gt; ByteCode (Async ())await    :: Async ()                      -&gt; ByteCode ()  The actual signatures use MonadFree which is an mtl-style class that allow us to compose FreeT with other monad transformers. We were able to monomorphize the return value MonadFree f m =&gt; m ~ Free ByteCodeF thanks to the instance Functor f =&gt; MonadFree f (Free f).Once we have the basic building blocks of our language, we can start building more complex primitives using monadic composition!loopN :: Integer -&gt; ByteCode ()loopN until = do  litI until  write n  litI 1  write i  loop (i &lt; n) (i ++)  where        (&lt;) i n = do      load n      load i      lessThan      ret        (++) i = do      litI 1      load i      add      write iInterpreting our eDSLNow that we have the building blocks to construct our domain specific programs, it is only remaining to implement an interpreter to evaluate this embedded DSL in our host language Haskell.The interpreter is usually implemented using iterM:iterM :: (Monad m, Functor f) =&gt; (f (m a) -&gt; m a) -&gt; Free f a -&gt; m aiterM _   (Pure x) = return xiterM phi (Free f) = phi (iterM phi &lt;$&gt; f)iterM allow us to collapse our Free f into a monadic value m a by providing a function f (m a) -&gt; m a (usually called an algebra) that operates on a single layer of our free monad. If you are familiar with recursion schemes, iterm is a specialization of cataA.This may sound confusing at first, but it is easier than it looks like. So, let’s see how it would look like in our example. First of all, we need to choose the monadic value m. For our interpreted language, we choose m ~ Interpreternewtype Interpreter a = Interpreter   { runInterpreter :: StateT Ctx (ExceptT Err IO) a }data Ctx = Ctx  { stack :: [Value],    variables :: Map Var Value  }data Err  = VariableNotFound Var  | StackIsEmpty  | BinaryOpExpectedTwoOperands  | AsyncException Text  | WhoNeedsTypeswhere Ctx is the current context of our program i.e. the state of the stack and the memory registers.Then, we specialize iterM to our example--       &lt;---------------- algebra -----------------&gt;iterm :: (ByteCodeF (Interpreter a) -&gt; Interpreter a) -&gt; ByteCode a -&gt; Interpreter aThe last step and usually the most difficult one is to implement the algebra of our DSLalgebra :: ByteCodeF (Interpreter a) -&gt; Interpreter aalgebra = \case  Ret f -&gt; popI &gt;&gt;= f  Lit i k -&gt; pushI i &gt;&gt; k  Load var k -&gt; loadI var &gt;&gt;= pushI &gt;&gt; k  Write var k -&gt; popI &gt;&gt;= storeI var &gt;&gt; k  BinaryOp op k -&gt;    do      catchError        (liftA2 (applyOp op) popI popI &gt;&gt;= either throwError pushI)        ( \case            StackIsEmpty -&gt; throwError BinaryOpExpectedTwoOperands            e -&gt; throwError e        )      &gt;&gt; k  Loop cond expr k -&gt;    fix $ \rec -&gt; do      b &lt;- interpret cond      if b        then interpret expr &gt;&gt; rec        else k  NewChan f -&gt;    liftIO getChan &gt;&gt;= f  Send chan k -&gt;    popI &gt;&gt;= (liftIO . sendChan chan) &gt;&gt; k  Recv chan k -&gt;    liftIO (recvChan chan) &gt;&gt;= pushI &gt;&gt; k  Fork branch k -&gt;    future branch &gt;&gt;= k  Await (Future async') k -&gt; do    ea &lt;- liftIO $ waitCatch async'    case ea of      Left (SomeException ex) -&gt; throwError (AsyncException (T.pack $ show ex))      Right (Left ex) -&gt; throwError (AsyncException (T.pack $ show ex))      Right _r -&gt; kpopI :: Interpreter ValuepopI = do  Ctx {..} &lt;- get  case stack of    [] -&gt; throwError StackIsEmpty    (x : xs) -&gt; put Ctx {stack = xs, ..} &gt;&gt; return xpushI :: Value -&gt; Interpreter ()pushI i = do  Ctx {..} &lt;- get  put Ctx {stack = i : stack, ..}loadI :: Var -&gt; Interpreter ValueloadI var = do  Ctx {..} &lt;- get  case M.lookup var variables of    Nothing -&gt; throwError $ VariableNotFound var    Just v -&gt; return vstoreI :: Var -&gt; Value -&gt; Interpreter ()storeI var v = do  Ctx {..} &lt;- get  let variables' = M.insert var v variables  put Ctx {variables = variables', ..}applyOp :: OpCode -&gt; Value -&gt; Value -&gt; Either Err ValueapplyOp Add (I i1) (I i2) = Right $ I (i1 + i2)applyOp Multiply (I i1) (I i2) = Right $ I (i1 * i2)applyOp LessThan (I i1) (I i2) = Right $ B (i1 &lt; i2)applyOp _ _ _ = Left WhoNeedsTypesfuture :: ByteCode a -&gt; Interpreter (Future a)future code = do  ctx &lt;- get  async' &lt;- liftIO . async . runExceptT $ evalStateT (runInterpreter (interpret code)) ctx  return $ Future async'Finally, we combine iterM and algebra to obtaininterpret :: ByteCode a -&gt; Interpreter ainterpret = iterM algebrawhich allow us to interpret our embedded language in our host language. The result of interpret can be composed with other effectful programs and it can also be evaluated using runByteCode:runByteCode :: ByteCode a -&gt; Either Err arunByteCode = unsafePerformIO . runExceptT . flip evalStateT emptyCtx . runInterpreter . interpretAll togetherSo far, we have built the following components:  An embedded stack-based language in Haskell with primitives like: lit, load, write, loop …  An interpreter for that language: interpret and runByteCode.Now that we have all the ingredients to create embedded stack-based programs and interpret them, we can put this into practise.program :: ByteCode Valueprogram = do  chan1 &lt;- newChan  chan2 &lt;- newChan  _ &lt;- fork $ do    loopN 100000    litI 1    send chan1  _ &lt;- fork $ do    loopN 100000    litI 1    send chan2  loopN 10  recv chan1  recv chan2  add  retmain :: IO ()main = case runByteCode program of  Left err -&gt; throw err  Right res -&gt; putStrLn $ "Result = " &lt;&gt; show resThe following program creates two asynchronous tasks that after a period of time, return the integer 1 through an asynchronous channel. The main program waits for these two asynchronous tasks to finish and outputs the sum of the results of the asynchronous tasks.ConclusionIn this post, we have introduced free monads and how they can be used to implement embedded domain specific languages. In particular, we have seen how to embed a stack-based language in Haskell. To see other examples of domain specific languages, we refer the reader to the examples of the free package.This post only covered a half of the free package. In the next post of this series, we’ll explore the other half: church encoding, applicative free, cofree…]]></content>
      <categories>
        
          <category> haskell </category>
        
      </categories>
      <tags>
        
          <tag> free monads </tag>
        
          <tag> eDSL </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Template Haskell; Use Cases]]></title>
      <url>/haskell/2021/10/14/th/</url>
      <content type="text"><![CDATA[IntroductionTemplate Haskell (TH) is an extension of GHC that allows the user to do type-safe compile-time meta-programming in Haskell. The idea behind template haskell comes from the paper “Template Meta-programming for Haskell” by S.P. Jones and T. Sheard. Template Haskell was shipped with GHC version 6.0. The compiler extension has evolved a lot since 2003 and its current state is well described at the GHC: User Manual and template-haskell package.Initially, TH offered the ability to generate code at compile time and allowed the programmer to manipulate the abstract syntax tree (AST) of the program. The addition of new capabilities such as lifting, TExp , runIO, and quasiquoting opened a bunch of new use cases to explore.In this blog post, we are going explore a bunch of interesting Template Haskell’s use cases:  Type Class Derivation  N-ary Function Generation  Compile-time Static Input Validation  Arbitrary IO at Compile TimeThis article assumes some familiarity with Haskell and, in particular, with Template Haskell. There are many well-written tutorials on the internet such as A Practical Template Haskell Tutorial or Template Haskell Tutorial.  We strongly recommend reading the previously mentioned tutorials before continuing with the reading.Use CasesBefore we start, these are the list of language extensions and imports that we are going to use in the following sections:{-# LANGUAGE AllowAmbiguousTypes #-}{-# LANGUAGE FlexibleInstances #-}{-# LANGUAGE OverloadedStrings #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE UndecidableInstances #-}{-# LANGUAGE ViewPatterns #-}import Codec.Pictureimport Control.Applicative (ZipList (..))import Control.Monad (replicateM, when)import Data.ByteString (ByteString)import qualified Data.ByteString as BSimport Data.Char (isSpace)import Data.Data hiding (cast)import Data.Foldableimport qualified Data.Text as Timport Data.Wordimport Instances.TH.Lift ()import Language.Haskell.THimport Language.Haskell.TH.Quoteimport Language.Haskell.TH.Syntaximport Network.HTTP.Reqimport Text.Read (readMaybe)import qualified Text.URI as URIEx 1: Type Class DerivationAutomatic derivation of type class instances is one of many problems that TH can solve. Although this problem can also be solved by generics, the compilation times are usually longer. For this reason, template haskell is still the preferred way to generate type class instances at compile time.Here we present an example of how to derive the type class Foldable for arbitrary datatypes.data List a   = Nil   | Cons a (List a)deriveFoldable ''ListThe implementation is as follows:data Deriving = Deriving { tyCon :: Name, tyVar :: Name }  deriving (Typeable)deriveFoldable :: Name -&gt; Q [Dec]deriveFoldable ty = do  (TyConI tyCon) &lt;- reify ty  (tyConName, tyVars, cs) &lt;- case tyCon of    DataD _ nm tyVars _ cs _   -&gt; return (nm, tyVars, cs)    NewtypeD _ nm tyVars _ c _ -&gt; return (nm, tyVars, [c])    _ -&gt; fail "deriveFoldable: tyCon may not be a type synonym."  let (KindedTV tyVar StarT) = last tyVars  putQ $ Deriving tyConName tyVar  let instanceType = conT ''Foldable `appT` foldl' apply (conT tyConName) (init tyVars)  foldableD &lt;- instanceD (return []) instanceType [genFoldMap cs]  return [foldableD]  where    apply t (PlainTV name)    = appT t (varT name)    apply t (KindedTV name _) = appT t (varT name)genFoldMap :: [Con] -&gt; Q DecgenFoldMap cs = funD 'foldMap (genFoldMapClause &lt;$&gt; cs)genFoldMapClause :: Con -&gt; Q ClausegenFoldMapClause (NormalC name fieldTypes)  = do f          &lt;- newName "f"       fieldNames &lt;- replicateM (length fieldTypes) (newName "x")       let pats = varP f : [conP name (map varP fieldNames)]           newFields = newField f &lt;$&gt; zip fieldNames (snd &lt;$&gt; fieldTypes)           body = normalB $             foldl' (\ b x -&gt; [| $b &lt;&gt; $x |]) (varE 'mempty) newFields       clause pats body []genFoldMapClause _ = error "Not supported yet"newField :: Name -&gt; (Name, Type) -&gt; ExpQnewField f (x, fieldType) = do  Just (Deriving typeCon typeVar) &lt;- getQ  case fieldType of    VarT typeVar' | typeVar' == typeVar -&gt;      [| $(varE f) $(varE x) |]    AppT ty (VarT typeVar') | leftmost ty == ConT typeCon &amp;&amp; typeVar' == typeVar -&gt;        [| foldMap $(varE f) $(varE x) |]    _ -&gt; [| mempty |]    leftmost :: Type -&gt; Typeleftmost (AppT ty1 _) = leftmost ty1leftmost ty           = tyEx 2: N-ary Function GenerationHave you ever written a function like snd3 :: (a, b, c) -&gt; b or snd4 :: (a, b, c, d) -&gt; b ? Then, you can do better by letting the compiler write those boilerplate and error-prone functions for you.Here we present an example of how to write an arbitrary-sized zipWith. We have chosen zipWith since it is a fairly simple function but complex enough to be used as the base to write more complex functions.Here is a first implementation of zipWithN:zipWithN :: Int -&gt; Q [Dec]zipWithN n  | n &gt;= 2 = sequence [funD name [cl1, cl2]]  | otherwise = fail "zipWithN: argument n may not be &lt; 2."  where    name = mkName $ "zipWith" ++ show n    cl1 = do      f &lt;- newName "f"      xs &lt;- replicateM n (newName "x")      yss &lt;- replicateM n (newName "ys")      let argPatts = varP f : consPatts          consPatts = [ [p| $(varP x) : $(varP ys) |]                      | (x, ys) &lt;- xs `zip` yss                      ]          apply = foldl (\ g x -&gt; [| $g $(varE x) |])          first = apply (varE f) xs          rest = apply (varE name) (f:yss)      clause argPatts (normalB [| $first : $rest |]) []    cl2 = clause (replicate (n+1) wildP) (normalB (conE '[])) []This implementation works fine but the compiler will warn you about a missing signature on a top-level definition.In order to fix this, we need to add a type signature to the generated term:zipWithN :: Int -&gt; Q [Dec]zipWithN n  | n &gt;= 2 = sequence [ sigD name ty, funD name [cl1, cl2] ]  ...  where    ...    ty = do      as &lt;- replicateM (n+1) (newName "a")      let apply = foldr (appT . appT arrowT)          funTy = apply (varT (last as)) (varT &lt;$&gt; init as)          listsTy = apply (appT listT (varT (last as))) (appT listT . varT &lt;$&gt; init as)      appT (appT arrowT funTy) listsTy        ...Now you can use zipWithN to generate arbitrary-sized zipWith functions:...$(zipWithN 6)$(zipWithN 7)$(zipWithN 8)...Manually generating each instance partially defeats the purpose of zipWithN.In order to address this issue, we need the auxiliary function genZipWith. Notice, we will use an alternative simplified definition of zipWithN that exploits slicing and lifting to showcase.genZipWith :: Int -&gt; Q [Dec]genZipWith n = traverse mkDec [1..n]  where    mkDec ith = do      let name = mkName $ "zipWith" ++ show ith ++ "'"      body &lt;- zipWithN ith      return $ FunD name [Clause [] (NormalB body) []]zipWithN :: Int -&gt; Q ExpzipWithN n = do    xss &lt;- replicateM n (newName "xs")    [| \f -&gt;        $(lamE (varP &lt;$&gt; xss)                [| getZipList                    $(foldl'                        (\ g xs -&gt; [| $g &lt;*&gt; $xs |])                        [| pure f |]                        (fmap (\xs -&gt; [| ZipList $(varE xs) |]) xss)                    )                |])    |]Now, we can generate arbitrary sized zipWith functions$(genZipWith' 20)which will produce zipWith1, zipWith2, …, zipWith19, zipWith20.Ex 3: Compile-time Input ValidationStatic input data is expected to be “correct” on a strongly typed programming language. For example, assigning the decimal number 256 to a variable of type Byte is expected to fail at compile time.So, let’s try it on Haskell:ghci&gt; :m +Data.Wordghci&gt; 256 :: Word8&lt;interactive&gt;:2:1: warning: [-Woverflowed-literals]    Literal 256 is out of the Word8 range 0..2550Ops! Indeed, the code has compiled with an unexpected overflow. The keen-eyed reader may be thinking that this bug could have been prevented with the appropriate GHC flags -Wall and -Werror.Here we present a more general approach to validate static input data from the user using quasiquoting. This example can be easily adapted to all sorts of input data.word :: QuasiQuoterword = QuasiQuoter  { quoteExp  = parseWord  , quotePat  = notHandled "patterns"  , quoteType = notHandled "types"  , quoteDec  = notHandled "declarations"  }  where notHandled things = error $          things ++ " are not handled by the word quasiquoter."parseWord :: String -&gt; Q ExpparseWord (trim -&gt; str) =  case words str of    [w] -&gt;      case break (== 'u') w of        (lit, size) -&gt;          case readMaybe @Integer lit of            Just int -&gt; do              when (int &lt; 0) $ fail "words are strictly positive"              case size of                "u8" -&gt; castWord @Word8 ''Word8 int                "u16" -&gt; castWord @Word16 ''Word16 int                "u32" -&gt; castWord @Word32 ''Word32 int                "u64" -&gt; castWord @Word64 ''Word64 int                _ -&gt; fail ("size " &lt;&gt; size &lt;&gt; " is not one of {u8, u16, u32, u64}")            Nothing -&gt; fail (lit &lt;&gt; " cannot be parsed as Integer")    _ -&gt; fail ("Unexpected word: " &lt;&gt; str)  where    castWord :: forall a. (Show a, Bounded a, Integral a) =&gt; Name -&gt; Integer -&gt; ExpQ    castWord ty int      | int &lt;= fromIntegral (maxBound @a) = sigE [|int|] (conT ty)      | otherwise = fail (pprint ty &lt;&gt; " is outside of bound: [0," &lt;&gt; show (maxBound @a) &lt;&gt; "]")trim :: String -&gt; Stringtrim = f . f where  f = reverse . dropWhile isSpaceThe word quasiquoter can validate static input dataghci&gt; [word| 255u8 |]255 :: Word8and emit a compilation-time error if the data is not validghci&gt; [word| 256u8 |]&lt;interactive&gt;:315:7-15: error:    * GHC.Word.Word8 is outside of bound: [0,255]    * In the quasi-quotation: [word| 256u8 |]Ex 4: Arbitrary IO at Compile TimeRunning arbitrary IO on compile-time is one of the features of TH. This allows the user to make compilation dependant on external conditions such as the database schema, the current git branch or a local file content.In this last example, we are going to use runIO and quasiquoting to get static pictures from remote and local files at compile-time. Notice, this example has been simplified to avoid all the overhead of proper error handling.  Try to parse the input string as an url  If it succeeds, request the content of the url as a bytestring  Otherwise, interpret the input string as a file path and read its content.  Decode the contents as a  DynamicImage  Lift the DynamicImageimg :: QuasiQuoterimg = QuasiQuoter {    quoteExp  = imgExpQ  , quotePat  = notHandled "patterns"  , quoteType = notHandled "types"  , quoteDec  = notHandled "declarations"  }  where notHandled things = error $          things ++ " are not handled by the img quasiquoter."imgExpQ :: String -&gt; ExpQimgExpQ str = do  uri' &lt;- URI.mkURI (T.pack str)  bs &lt;- runIO $ do    (bs, dynImg) &lt;-       case useURI uri' of        Nothing -&gt; BS.readFile str        Just (Left (url, _)) -&gt; requestBs url        Just (Right (url, _)) -&gt; requestBs url    either fail (pure . (bs,)) $ decodeImage bs  liftDynamicImage bsliftDynamicImage :: ByteString -&gt; Q ExpliftDynamicImage bs = [| either error id (decodeImage bs) |]requestBs :: Url scheme -&gt; IO ByteStringrequestBs url =  runReq defaultHttpConfig $ do    r &lt;- req            GET            url            NoReqBody            bsResponse            mempty    return (responseBody r)The img quasiquoter can be used to load pictures as static data inside your binarydynImg1 :: DynamicImagedynImg1 = [img|https://httpbin.org/image/jpeg|]dynImg2 :: DynamicImagedynImg2 = [img|./resources/pig.png|]ConclusionDuring this blog post, we have seem some of the use cases of template haskell and how to implement them.We encourage the reader to use our examples to build new and more compelling use cases of template haskell and to share them with the community.We hope you enjoyed this post and don’t forget to share your own use cases for template haskell in the comments.]]></content>
      <categories>
        
          <category> haskell </category>
        
      </categories>
      <tags>
        
          <tag> template-haskell </tag>
        
          <tag> meta-programming </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[The Fizz Buzz problem]]></title>
      <url>/haskell/2021/09/24/fizz-buzz/</url>
      <content type="text"><![CDATA[This morning, I saw this blog by @cercerilla on twitter. I was fascinated by her implementation but I couldn’t believe how many lines of code it took to write such a simple program! The Fizz Buzz problem can be implemented on the term level with only a few lines of code:fizz :: Int -&gt; Stringfizz n | n `mod` 15 == 0  = "FizzBuzz"       | n `mod` 3  == 0  = "Fizz"       | n `mod` 5  == 0  = "Buzz"       | otherwise        = show nmain :: IO()main = traverse_ (putStrLn . fizz) [1..100]One of the main problems of type-level programming in Haskell is that you cannot implement higher-order functions on the type level (see saturation restriction). Therefore, we cannot abstract as much as we do on the term level using traverse and [1..100]. There is an accepted proposal unsaturated type families but it still not merged into GHC.Are we doomed to write a lot of boilerplate code as in @cercerilla example? The answer is no, there is a workaround to this problem called defunctionalization. Defunctionalization translates higher-order functions into first-order functions:  Instead of working with functions, work with symbols representing functions.  Build your final functions and values by composing and combining these symbols.  At the end of it all, have a single apply function interpret all of your symbols and produce the value you want.This idea of defunctionalization is implemented in the singletons and in first-class-families.Below we present the implementation of Fizz Buzz on the type-level using the singletons library(you can achieve a similar result using fcf package). The implementation is many times smaller than the one implemented using ad hoc higher-order combinators and easier to understand since most of the complexity is moved away to the singletons’ library.{-# LANGUAGE AllowAmbiguousTypes #-}{-# LANGUAGE DataKinds #-}{-# LANGUAGE FlexibleContexts #-}{-# LANGUAGE RankNTypes #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE StandaloneKindSignatures #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE TypeFamilies #-}{-# LANGUAGE TypeOperators #-}{-# LANGUAGE UndecidableInstances #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE PolyKinds #-}{-# LANGUAGE GADTs #-}module FizzBuzz whereimport Data.Singletons.THimport Data.Singletons.Preludeimport Data.Singletons.TypeLits$(singletons [d|  type Divisible n by = Mod n by == 0  type FizzBuzzElem :: Nat -&gt; Symbol  type FizzBuzzElem n =      If        (Divisible n 15)        "FizzBuzz"        ( If            (Divisible n 3)            "Fizz"            ( If                (Divisible n 5)                "Buzz"                (Show_ n)))  |])type FizzBuzz n = Fmap FizzBuzzElemSym0 (EnumFromTo 1 n)-- |-- &gt;&gt;&gt; fizzBuzz @10-- "[FizzBuzz,1,2,Fizz,4,Buzz,Fizz,7,8,Fizz]"fizzBuzz :: forall (n :: Nat). (KnownSymbol (Show_ (FizzBuzz n))) =&gt; StringfizzBuzz = symbolVal (Proxy @(Show_ (FizzBuzz n)))Type-level programming in Haskell is still a difficult task since the support for higher-order abstractions is still not available in the language. With the use of libraries such as singletons we can make this task less difficult reusing many higher-order abstractions on the type level.]]></content>
      <categories>
        
          <category> haskell </category>
        
      </categories>
      <tags>
        
          <tag> type-level programming </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Running a Haskell Script without GHC]]></title>
      <url>/haskell/nix/2020/03/10/running-haskell-scripts/</url>
      <content type="text"><![CDATA[IntroductionGiven the following haskell script generate-random-samples.hs that requires mwc-random{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vs… how do you run it without having to globally install the package or having to build a whole cabal project ?Initial approachOne of the simplest approaches using nix is the following:$ nix-shell --packages 'haskellPackages.ghcWithHoogle (pkgs: with pkgs; [ mwc-random ])'nix-shell&gt; runghc generate-random-samples.hsIn order to reuse the command so other people can run the script, you can add the following shell.nix:{ compiler ? "ghc881" }:let  pkgs = import (builtins.fetchGit {    url = "https://github.com/NixOS/nixpkgs.git";    rev = "890440b0273caab258b38c0873c3fe758318bb4f";    ref = "master";  }) {};  ghc = pkgs.haskell.packages.${compiler}.ghcWithPackages (ps: with ps; [          mwc-random        ]);inpkgs.stdenv.mkDerivation {  name = "ghc-env";  buildInputs = [ ghc pkgs.cabal-install ];  shellHook = "eval $(egrep ^export ${ghc}/bin/ghc)";}So now you only need to call $ nix-shell to enter into a pure shell with a specific GHC version that includes all your dependencies:$ nix-shellnix-shell&gt; runghc generate-random-samples.hsImproving the first approachThe only issue is that you must be aware of how nix work in order to be able to run the script.But these could be solved using bash shebangs in your haskell script:#!/usr/bin/env nix-shell#!nix-shell -i runghc{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vsSo now, you can run your haskell script in an environment without ghc:./generate-random-samples.hs[6052359640365008112,3693984866634705670,6521947999724514858,640433474764908030,-4262896110044960033,-1795671341099353119,-2220462704949887998,-248182841640258167,709016591698961687,-3622504171575206589,5987258113070378446,-159251391303273987,-8449937247808153766,6165509553180365166,-8199532339362621783,-9187765480154042269,-2389922548196927048,-4842141643835297495,-1106748185069026877,826927505518387091]Update: 11-03-2020After reading the following comment in reddit, I think it is worth mentioning that you can achieve better modularity in exchange of maintainability, by having everything on the haskell script, without having to depend on a shell.nix file:#!/usr/bin/env nix-shell#!nix-shell -i runghc -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [ mwc-random ])"#!nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/d373d80b1207d52621961b16aa4a3438e4f98167.tar.gz{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vs]]></content>
      <categories>
        
          <category> haskell </category>
        
          <category> nix </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
