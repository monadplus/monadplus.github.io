<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Template Haskell — Use Cases]]></title>
      <url>/haskell/2021/10/14/th/</url>
      <content type="text"><![CDATA[IntroductionTemplate Haskell (TH) is an extension of GHC that allows the user to do type-safe compile-time meta-programming in Haskell. The idea behind template haskell comes from the paper “Template Meta-programming for Haskell” by S.P. Jones and T. Sheard. Template Haskell was shipped with GHC version 6.0. The compiler extension has evolved a lot since 2003 and its current state is well described at the GHC: User Manual and template-haskell package.Initially, TH offered the ability to generate code at compile time and allowed the programmer to manipulate the abstract syntax tree (AST) of the program. The addition of new capabilities such as lifting, TExp , runIO, and quasiquoting opened a bunch of new use cases to explore.In this blog post, we are going explore a bunch of interesting Template Haskell’s use cases:  Type Class Derivation  N-ary Function Generation  Compile-time Static Input Validation  Arbitrary IO at Compile TimeThis article assumes some familiarity with Haskell and, in particular, with Template Haskell. There are many well-written tutorials on the internet such as A Practical Template Haskell Tutorial or Template Haskell Tutorial.  We strongly recommend reading the previously mentioned tutorials before continuing with the reading.Use CasesBefore we start, these are the list of language extensions and imports that we are going to use in the following sections:{-# LANGUAGE AllowAmbiguousTypes #-}{-# LANGUAGE FlexibleInstances #-}{-# LANGUAGE OverloadedStrings #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE UndecidableInstances #-}{-# LANGUAGE ViewPatterns #-}import Codec.Pictureimport Control.Applicative (ZipList (..))import Control.Monad (replicateM, when)import Data.ByteString (ByteString)import qualified Data.ByteString as BSimport Data.Char (isSpace)import Data.Data hiding (cast)import Data.Foldableimport qualified Data.Text as Timport Data.Wordimport Instances.TH.Lift ()import Language.Haskell.THimport Language.Haskell.TH.Quoteimport Language.Haskell.TH.Syntaximport Network.HTTP.Reqimport Text.Read (readMaybe)import qualified Text.URI as URIEx 1: Type Class DerivationAutomatic derivation of type class instances is one of many problems that TH can solve. Although this problem can also be solved by generics, the compilation times are usually longer. For this reason, template haskell is still the preferred way to generate type class instances at compile time.Here we present an example of how to derive the type class Foldable for arbitrary datatypes.data List a   = Nil   | Cons a (List a)deriveFoldable ''ListThe implementation is as follows:data Deriving = Deriving { tyCon :: Name, tyVar :: Name }  deriving (Typeable)deriveFoldable :: Name -&gt; Q [Dec]deriveFoldable ty = do  (TyConI tyCon) &lt;- reify ty  (tyConName, tyVars, cs) &lt;- case tyCon of    DataD _ nm tyVars _ cs _   -&gt; return (nm, tyVars, cs)    NewtypeD _ nm tyVars _ c _ -&gt; return (nm, tyVars, [c])    _ -&gt; fail "deriveFoldable: tyCon may not be a type synonym."  let (KindedTV tyVar StarT) = last tyVars  putQ $ Deriving tyConName tyVar  let instanceType = conT ''Foldable `appT` foldl' apply (conT tyConName) (init tyVars)  foldableD &lt;- instanceD (return []) instanceType [genFoldMap cs]  return [foldableD]  where    apply t (PlainTV name)    = appT t (varT name)    apply t (KindedTV name _) = appT t (varT name)genFoldMap :: [Con] -&gt; Q DecgenFoldMap cs = funD 'foldMap (genFoldMapClause &lt;$&gt; cs)genFoldMapClause :: Con -&gt; Q ClausegenFoldMapClause (NormalC name fieldTypes)  = do f          &lt;- newName "f"       fieldNames &lt;- replicateM (length fieldTypes) (newName "x")       let pats = varP f : [conP name (map varP fieldNames)]           newFields = newField f &lt;$&gt; zip fieldNames (snd &lt;$&gt; fieldTypes)           body = normalB $             foldl' (\ b x -&gt; [| $b &lt;&gt; $x |]) (varE 'mempty) newFields       clause pats body []genFoldMapClause _ = error "Not supported yet"newField :: Name -&gt; (Name, Type) -&gt; ExpQnewField f (x, fieldType) = do  Just (Deriving typeCon typeVar) &lt;- getQ  case fieldType of    VarT typeVar' | typeVar' == typeVar -&gt;      [| $(varE f) $(varE x) |]    AppT ty (VarT typeVar') | leftmost ty == ConT typeCon &amp;&amp; typeVar' == typeVar -&gt;        [| foldMap $(varE f) $(varE x) |]    _ -&gt; [| mempty |]    leftmost :: Type -&gt; Typeleftmost (AppT ty1 _) = leftmost ty1leftmost ty           = tyEx 2: N-ary Function GenerationHave you ever written a function like snd3 :: (a, b, c) -&gt; b or snd4 :: (a, b, c, d) -&gt; b ? Then, you can do better by letting the compiler write those boilerplate and error-prone functions for you.Here we present an example of how to write an arbitrary-sized zipWith. We have chosen zipWith since it is a fairly simple function but complex enough to be used as the base to write more complex functions.Here is a first implementation of zipWithN:zipWithN :: Int -&gt; Q [Dec]zipWithN n  | n &gt;= 2 = sequence [funD name [cl1, cl2]]  | otherwise = fail "zipWithN: argument n may not be &lt; 2."  where    name = mkName $ "zipWith" ++ show n    cl1 = do      f &lt;- newName "f"      xs &lt;- replicateM n (newName "x")      yss &lt;- replicateM n (newName "ys")      let argPatts = varP f : consPatts          consPatts = [ [p| $(varP x) : $(varP ys) |]                      | (x, ys) &lt;- xs `zip` yss                      ]          apply = foldl (\ g x -&gt; [| $g $(varE x) |])          first = apply (varE f) xs          rest = apply (varE name) (f:yss)      clause argPatts (normalB [| $first : $rest |]) []    cl2 = clause (replicate (n+1) wildP) (normalB (conE '[])) []This implementation works fine but the compiler will warn you about a missing signature on a top-level definition.In order to fix this, we need to add a type signature to the generated term:zipWithN :: Int -&gt; Q [Dec]zipWithN n  | n &gt;= 2 = sequence [ sigD name ty, funD name [cl1, cl2] ]  ...  where    ...    ty = do      as &lt;- replicateM (n+1) (newName "a")      let apply = foldr (appT . appT arrowT)          funTy = apply (varT (last as)) (varT &lt;$&gt; init as)          listsTy = apply (appT listT (varT (last as))) (appT listT . varT &lt;$&gt; init as)      appT (appT arrowT funTy) listsTy        ...Now you can use zipWithN to generate arbitrary-sized zipWith functions:...$(zipWithN 6)$(zipWithN 7)$(zipWithN 8)...Manually generating each instance partially defeats the purpose of zipWithN.In order to address this issue, we need the auxiliary function genZipWith. Notice, we will use an alternative simplified definition of zipWithN that exploits slicing and lifting to showcase.genZipWith :: Int -&gt; Q [Dec]genZipWith n = traverse mkDec [1..n]  where    mkDec ith = do      let name = mkName $ "zipWith" ++ show ith ++ "'"      body &lt;- zipWithN ith      return $ FunD name [Clause [] (NormalB body) []]zipWithN :: Int -&gt; Q ExpzipWithN n = do    xss &lt;- replicateM n (newName "xs")    [| \f -&gt;        $(lamE (varP &lt;$&gt; xss)                [| getZipList                    $(foldl'                        (\ g xs -&gt; [| $g &lt;*&gt; $xs |])                        [| pure f |]                        (fmap (\xs -&gt; [| ZipList $(varE xs) |]) xss)                    )                |])    |]Now, we can generate arbitrary sized zipWith functions$(genZipWith' 20)which will produce zipWith1, zipWith2, …, zipWith19, zipWith20.Ex 3: Compile-time Input ValidationStatic input data is expected to be “correct” on a strongly typed programming language. For example, assigning the decimal number 256 to a variable of type Byte is expected to fail at compile time.So, let’s try it on Haskell:ghci&gt; :m +Data.Wordghci&gt; 256 :: Word8&lt;interactive&gt;:2:1: warning: [-Woverflowed-literals]    Literal 256 is out of the Word8 range 0..2550Ops! Indeed, the code has compiled with an unexpected overflow. The keen-eyed reader may be thinking that this bug could have been prevented with the appropriate GHC flags -Wall and -Werror.Here we present a more general approach to validate static input data from the user using quasiquoting. This example can be easily adapted to all sorts of input data.word :: QuasiQuoterword = QuasiQuoter  { quoteExp  = parseWord  , quotePat  = notHandled "patterns"  , quoteType = notHandled "types"  , quoteDec  = notHandled "declarations"  }  where notHandled things = error $          things ++ " are not handled by the word quasiquoter."parseWord :: String -&gt; Q ExpparseWord (trim -&gt; str) =  case words str of    [w] -&gt;      case break (== 'u') w of        (lit, size) -&gt;          case readMaybe @Integer lit of            Just int -&gt; do              when (int &lt; 0) $ fail "words are strictly positive"              case size of                "u8" -&gt; castWord @Word8 ''Word8 int                "u16" -&gt; castWord @Word16 ''Word16 int                "u32" -&gt; castWord @Word32 ''Word32 int                "u64" -&gt; castWord @Word64 ''Word64 int                _ -&gt; fail ("size " &lt;&gt; size &lt;&gt; " is not one of {u8, u16, u32, u64}")            Nothing -&gt; fail (lit &lt;&gt; " cannot be parsed as Integer")    _ -&gt; fail ("Unexpected word: " &lt;&gt; str)  where    castWord :: forall a. (Show a, Bounded a, Integral a) =&gt; Name -&gt; Integer -&gt; ExpQ    castWord ty int      | int &lt;= fromIntegral (maxBound @a) = sigE [|int|] (conT ty)      | otherwise = fail (pprint ty &lt;&gt; " is outside of bound: [0," &lt;&gt; show (maxBound @a) &lt;&gt; "]")trim :: String -&gt; Stringtrim = f . f where  f = reverse . dropWhile isSpaceThe word quasiquoter can validate static input dataghci&gt; [word| 255u8 |]255 :: Word8and emit a compilation-time error if the data is not validghci&gt; [word| 256u8 |]&lt;interactive&gt;:315:7-15: error:    * GHC.Word.Word8 is outside of bound: [0,255]    * In the quasi-quotation: [word| 256u8 |]Ex 4: Arbitrary IO at Compile TimeRunning arbitrary IO on compile-time is one of the features of TH. This allows the user to make compilation dependant on external conditions such as the database schema, the current git branch or a local file content.In this last example, we are going to use runIO and quasiquoting to get static pictures from remote and local files at compile-time. Notice, this example has been simplified to avoid all the overhead of proper error handling.  Try to parse the input string as an url  If it succeeds, request the content of the url as a bytestring  Otherwise, interpret the input string as a file path and read its content.  Decode the contents as a  DynamicImage  Lift the DynamicImageimg :: QuasiQuoterimg = QuasiQuoter {    quoteExp  = imgExpQ  , quotePat  = notHandled "patterns"  , quoteType = notHandled "types"  , quoteDec  = notHandled "declarations"  }  where notHandled things = error $          things ++ " are not handled by the img quasiquoter."imgExpQ :: String -&gt; ExpQimgExpQ str = do  uri' &lt;- URI.mkURI (T.pack str)  bs &lt;- runIO $ do    (bs, dynImg) &lt;-       case useURI uri' of        Nothing -&gt; BS.readFile str        Just (Left (url, _)) -&gt; requestBs url        Just (Right (url, _)) -&gt; requestBs url    either fail (pure . (bs,)) $ decodeImage bs  liftDynamicImage bsliftDynamicImage :: ByteString -&gt; Q ExpliftDynamicImage bs = [| either error id (decodeImage bs) |]requestBs :: Url scheme -&gt; IO ByteStringrequestBs url =  runReq defaultHttpConfig $ do    r &lt;- req            GET            url            NoReqBody            bsResponse            mempty    return (responseBody r)The img quasiquoter can be used to load pictures as static data inside your binarydynImg1 :: DynamicImagedynImg1 = [img|https://httpbin.org/image/jpeg|]dynImg2 :: DynamicImagedynImg2 = [img|./resources/pig.png|]ConclusionDuring this blog post, we have seem some of the use cases of template haskell and how to implement them.We encourage the reader to use our examples to build new and more compelling use cases of template haskell and to share them with the community.We hope you enjoyed this post and don’t forget to share your own use cases for template haskell in the comments.]]></content>
      <categories>
        
          <category> haskell </category>
        
      </categories>
      <tags>
        
          <tag> haskell </tag>
        
          <tag> template-haskell </tag>
        
          <tag> meta-programming </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[The Fizz Buzz problem]]></title>
      <url>/haskell/2021/09/24/fizz-buzz/</url>
      <content type="text"><![CDATA[This morning, I saw this blog by @cercerilla on twitter. I was fascinated by her implementation but I couldn’t believe how many lines of code it took to write such a simple program! The Fizz Buzz problem can be implemented on the term level with only a few lines of code:fizz :: Int -&gt; Stringfizz n | n `mod` 15 == 0  = "FizzBuzz"       | n `mod` 3  == 0  = "Fizz"       | n `mod` 5  == 0  = "Buzz"       | otherwise        = show nmain :: IO()main = traverse_ (putStrLn . fizz) [1..100]One of the main problems of type-level programming in Haskell is that you cannot implement higher-order functions on the type level (see saturation restriction). Therefore, we cannot abstract as much as we do on the term level using traverse and [1..100]. There is an accepted proposal unsaturated type families but it still not merged into GHC.Are we doomed to write a lot of boilerplate code as in @cercerilla example? The answer is no, there is a workaround to this problem called defunctionalization. Defunctionalization translates higher-order functions into first-order functions:  Instead of working with functions, work with symbols representing functions.  Build your final functions and values by composing and combining these symbols.  At the end of it all, have a single apply function interpret all of your symbols and produce the value you want.This idea of defunctionalization is implemented in the singletons and in first-class-families.Below we present the implementation of Fizz Buzz on the type-level using the singletons library(you can achieve a similar result using fcf package). The implementation is many times smaller than the one implemented using ad hoc higher-order combinators and easier to understand since most of the complexity is moved away to the singletons’ library.{-# LANGUAGE AllowAmbiguousTypes #-}{-# LANGUAGE DataKinds #-}{-# LANGUAGE FlexibleContexts #-}{-# LANGUAGE RankNTypes #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE StandaloneKindSignatures #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE TypeFamilies #-}{-# LANGUAGE TypeOperators #-}{-# LANGUAGE UndecidableInstances #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE PolyKinds #-}{-# LANGUAGE GADTs #-}module FizzBuzz whereimport Data.Singletons.THimport Data.Singletons.Preludeimport Data.Singletons.TypeLits$(singletons [d|  type Divisible n by = Mod n by == 0  type FizzBuzzElem :: Nat -&gt; Symbol  type FizzBuzzElem n =      If        (Divisible n 15)        "FizzBuzz"        ( If            (Divisible n 3)            "Fizz"            ( If                (Divisible n 5)                "Buzz"                (Show_ n)))  |])type FizzBuzz n = Fmap FizzBuzzElemSym0 (EnumFromTo 1 n)-- |-- &gt;&gt;&gt; fizzBuzz @10-- "[FizzBuzz,1,2,Fizz,4,Buzz,Fizz,7,8,Fizz]"fizzBuzz :: forall (n :: Nat). (KnownSymbol (Show_ (FizzBuzz n))) =&gt; StringfizzBuzz = symbolVal (Proxy @(Show_ (FizzBuzz n)))Type-level programming in Haskell is still a difficult task since the support for higher-order abstractions is still not available in the language. With the use of libraries such as singletons we can make this task less difficult reusing many higher-order abstractions on the type level.]]></content>
      <categories>
        
          <category> haskell </category>
        
      </categories>
      <tags>
        
          <tag> haskell </tag>
        
          <tag> type-level programming </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Running a Haskell Script without GHC]]></title>
      <url>/haskell/nix/2020/03/10/running-haskell-scripts/</url>
      <content type="text"><![CDATA[IntroductionGiven the following haskell script generate-random-samples.hs that requires mwc-random{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vs… how do you run it without having to globally install the package or having to build a whole cabal project ?Initial approachOne of the simplest approaches using nix is the following:$ nix-shell --packages 'haskellPackages.ghcWithHoogle (pkgs: with pkgs; [ mwc-random ])'nix-shell&gt; runghc generate-random-samples.hsIn order to reuse the command so other people can run the script, you can add the following shell.nix:{ compiler ? "ghc881" }:let  pkgs = import (builtins.fetchGit {    url = "https://github.com/NixOS/nixpkgs.git";    rev = "890440b0273caab258b38c0873c3fe758318bb4f";    ref = "master";  }) {};  ghc = pkgs.haskell.packages.${compiler}.ghcWithPackages (ps: with ps; [          mwc-random        ]);inpkgs.stdenv.mkDerivation {  name = "ghc-env";  buildInputs = [ ghc pkgs.cabal-install ];  shellHook = "eval $(egrep ^export ${ghc}/bin/ghc)";}So now you only need to call $ nix-shell to enter into a pure shell with a specific GHC version that includes all your dependencies:$ nix-shellnix-shell&gt; runghc generate-random-samples.hsImproving the first approachThe only issue is that you must be aware of how nix work in order to be able to run the script.But these could be solved using bash shebangs in your haskell script:#!/usr/bin/env nix-shell#!nix-shell -i runghc{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vsSo now, you can run your haskell script in an environment without ghc:./generate-random-samples.hs[6052359640365008112,3693984866634705670,6521947999724514858,640433474764908030,-4262896110044960033,-1795671341099353119,-2220462704949887998,-248182841640258167,709016591698961687,-3622504171575206589,5987258113070378446,-159251391303273987,-8449937247808153766,6165509553180365166,-8199532339362621783,-9187765480154042269,-2389922548196927048,-4842141643835297495,-1106748185069026877,826927505518387091]Update: 11-03-2020After reading the following comment in reddit, I think it is worth mentioning that you can achieve better modularity in exchange of maintainability, by having everything on the haskell script, without having to depend on a shell.nix file:#!/usr/bin/env nix-shell#!nix-shell -i runghc -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [ mwc-random ])"#!nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/d373d80b1207d52621961b16aa4a3438e4f98167.tar.gz{-# LANGUAGE ScopedTypeVariables #-}import System.Random.MWCimport Data.Vector.Unboxedimport Control.Monad.STmain = do  vs &lt;- withSystemRandom $        \(gen::GenST s) -&gt; uniformVector gen 20 :: ST s (Vector Int)  print vs]]></content>
      <categories>
        
          <category> haskell </category>
        
          <category> nix </category>
        
      </categories>
      <tags>
        
          <tag> haskell </tag>
        
          <tag> nix </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
